#!/usr/bin/zsh

typeset -A _zs_assoc_s=(ns '(S)' gns '(S)' nsg '(S)')
typeset -A _zs_assoc_r=(gs / sg / gns / nsg /)

zs()
{
  local prefix='' suffix='' prefixcmd=f cmd= e='eval echo'
  local -i i=1 toto=$#@

  setopt localoptions extendedglob

  for ((i=1; $i<=$toto; i+=2)) {
    case $@[$i] in
      (s|gs|sg|ns|gns|nsg)
        prefix=$prefix'${'$_zs_assoc_s[$@[$i]]
        suffix+=$_zs_assoc_r[$@[$i]]/${@[$(($i+1))]//(#m)[\/\'\"\\]/\\$MATCH}/$@[$(($i+2))]'}'
        i+=1 ;;
      (i) prefix=${prefix[1,-2]}'I:'$@[$(($i+1))]':)' ;;
      (d) prefix=$prefix'${'; suffix+=':#'${@[$(($i+1))]//(#m)[\/\'\"\\]/\\$MATCH}'}' ;;
      (g) prefix=$prefix'${(M)'; suffix+=':#'${@[$(($i+1))]//(#m)[\/\'\"\\]/\\$MATCH}'}' ;;
      (f) cmd+='<'${(q)@[$(($i+1))]}';' ;;
      (p) e=$@[$(($i+1))] ;;
      (c) cmd+=${(q)@[$(($i+1))]}';' ;;
      (z) cmd+=${@[$(($i+1))]}';' ;;
      (t) prefixcmd='' ;;
      (n) prefixcmd='@f' ;;
      (h|-h) echo "$0: [{s|gs|ns|gns|d|g} pattern] [i nth] [p progname] [c cmd] [z expr] [t|n] [[f] file] ...
- s: replace
- gs: global replace
- ns: replace non-greedy
- gns: global replace non-greedy
- i: exprth match, only with ns and gns
- d: delete
- g: keep
- p: evaluator
- c: command
- z: zsh expression
- f: read file
- t: read plain file
- n: read by line with empty line
"; return 1 ;;
      (*) cmd+='<'${(q)@[$i]}';' ; i+=-1 ;;
    esac
  }

  $=e "\${${prefixcmd:+(F)}$prefix\${${prefixcmd:+($prefixcmd)}\"\$(${cmd:-</dev/stdin})\"}$suffix}"
}
