#!/bin/zsh
zg() {
  local e='echo ' m='(M)' j='(F)' n=@ d=f p=eval C=
  typeset -i M=1 t=0 X=0 v=0 a=0 x=1

  while getopts p:e:d:j:C:MvVacsnxXhrR opt ; do
    case $opt in
      (e) e=$OPTARG' ' ;;
      (r) e='reply=(' ; j= ;;
      (R) e='REPLY=' ;;
      (d) d=$OPTARG ;;
      (j) j=${OPTARG:+\($OPTARG\)} ;;
      (C) C=$OPTARG ; ((M-=1)) ;;
      (M) ((M+=1)) ;;
      (v) m= ;;
      (V) v= ;;
      (a) a=1 ;;
      (c) t=1 ;;
      (s) t=2 ;;
      (X) X=1 ;;
      (x) x=0 ;;
      (n) n= ;;
      (p) p=$OPTARG ;;
      (h|\?) echo 'zsh grep
zg [-e cmd | -r | -R] [-d zshopt] [-j zshopt] [-C pattern_for_color ] [-p cmd] [-MXVvavsnxh] [--] pattern [{ files | expression | command ... }]
 -e: execute command
 -r saved array in the parameter `reply`
 -R saved string in the parameter `REPLY`
 -d: example: s:,: of ${(s:,:)line}
 -j: join lines with specified zsh option. example: `j:,:` of ${(j:,:)array}
 -C: pattern for color ; disable filter
 -M: enable pattern filter event with -C
 -a: deduct -C from the pattern
 -v: invert match
 -V: invert color match
 -c: files as a command
 -s: files as a expression
 -n: ignore empty line
 -X: colorizes the first occurrence only
 -x: select only those matches that exactly match the whole line
 -p: set expression evaluator, default is `eval`'
        [ $opt = h ] ; return $?
        ;;
      *) break
    esac
  done

  [ $M -le 0 ] && m=

  if [ ! -z $C ]; then
    [ $v -eq 1 ] && m='${'$m
  elif [ $a -eq 1 ]; then
    C=${@[$OPTIND]}
    if [ $x -eq 0 ]; then
      [ $C[1] != '*' ]
      local -i starpre=$?
      [ $C[$#C] != '*' ]
      local -i starsuf=$?

      if [ $(($starpre+$starsuf)) -eq 2 ]; then
        C=${C[2,-2]}
      elif [ $starsuf -eq 1 ]; then
        C=${C[1,-2]}
        X=2
      elif [ $starpre -eq 1 ]; then
        C=${C[2,$]}
        X=3
      else
        X=1
      fi
    fi
  fi

  n+=$d
  d=$e[$#e]
  e+='${'$j'${'$m'${'${n:+\($n\)}

  if [ $M -gt 0 ]; then
    if [ $x -eq 1 ]; then
      m='}:#'
      [[ ${@[$OPTIND]} = ([^^*$|]*) ]] && m+='*'
      m+=${@[$OPTIND]}
      [[ ${@[$OPTIND]} = (*[^^*$|]) ]] && m+='*'
      m+='}'
    else
      m='}:#'${@[$OPTIND]}'}'
    fi
  else
    m='}}'
    ((OPTIND-=1))
  fi

  if [ ! -z $C ]; then
    setopt localoptions extendedglob
    if [ $X -eq 3 ]; then
      C+='(#e)'
    elif [ $X -eq 2 ]; then
      C='(#s)'$C
    elif [ $X -eq 0 ]; then
      m+=/
    fi

    if [ $v -eq 1 ]; then
      m=+'/(#m)'$C'/\\e[0m${MATCH}\\e[${GREP_COLOR}m}/(#m)*/\\e[${GREP_COLOR}m${MATCH}\\e[0m'
    else
      m+='/(#m)'$C'/\\e[${GREP_COLOR}m${MATCH}\\e[0m'
    fi
  fi

  [ $d = '(' ] && m+='})' || m+='}'

  shift $OPTIND

  if [ $# -eq 0 ]; then
    $p $e'"$(</dev/stdin)"'$m
  elif [ $t = 0 ]; then
    $p $e'"$(<'${(j:<:)${(q)@}}')"'$m
  elif [ $t = 1 ]; then
    $p $e'"$('${(q)@}')"'$m
  else
    $p $e'@'$m
  fi
}
