# add a function path
# fpath=($ZSH/functions $ZSH/completions $fpath)

# Load all of the config files in ~/oh-my-zsh that end in .zsh
# TIP: Add files you don't want in git to .gitignore
# for config_file ($ZSH/lib/*.zsh); do
#   source $config_file
# done


## aliases

# Push and pop directories on directory stack
alias pu='pushd'
alias po='popd'

# Basic directory operations
alias ...='cd ../..'
alias -- -='cd -'

# Super user
# alias _='sudo'
# alias please='sudo'

#alias g='grep -in'

# Show history
# if [ "$HIST_STAMPS" = "mm/dd/yyyy" ]
# then
#     alias history='fc -fl 1'
# elif [ "$HIST_STAMPS" = "dd.mm.yyyy" ]
# then
#     alias history='fc -El 1'
# elif [ "$HIST_STAMPS" = "yyyy-mm-dd" ]
# then
#     alias history='fc -il 1'
# else
#     alias history='fc -l 1'
# fi
alias history='fc -l 1'

# alias afind='ack-grep -il'


## completion

unsetopt menu_complete   # do not autoselect the first completion entry
unsetopt flowcontrol
setopt auto_menu         # show completion menu on succesive tab press
setopt complete_in_word
setopt always_to_end

WORDCHARS=''

zmodload -i zsh/complist

## case-insensitive (all),partial-word and then substring completion
# if [ "x$CASE_SENSITIVE" = "xtrue" ]; then
#   zstyle ':completion:*' matcher-list 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'
#   unset CASE_SENSITIVE
# else
  zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'
# fi

# zstyle ':completion:*' list-colors ''

# should this be in keybindings?
bindkey -M menuselect '^o' accept-and-infer-next-history

zstyle ':completion:*:*:*:*:*' menu select
zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#) ([0-9a-z-]#)*=31=0=34'
zstyle ':completion:*:*:*:*:processes' command "ps -u$USER -o pid,user,comm -w"

# disable named-directories autocompletion
zstyle ':completion:*:cd:*' tag-order local-directories directory-stack path-directories
cdpath=(.)

# use /etc/hosts and known_hosts for hostname completion
# [ -r /etc/ssh/ssh_known_hosts ] && _global_ssh_hosts=(${${${${(f)"$(</etc/ssh/ssh_known_hosts)"}:#[\|]*}%%\ *}%%,*}) || _global_ssh_hosts=()
# [ -r ~/.ssh/known_hosts ] && _ssh_hosts=(${${${${(f)"$(<$HOME/.ssh/known_hosts)"}:#[\|]*}%%\ *}%%,*}) || _ssh_hosts=()
# [ -r ~/.ssh/config ] && _ssh_config=($(cat ~/.ssh/config | sed -ne 's/Host[=\t ]//p')) || _ssh_config=()
# [ -r /etc/hosts ] && : ${(A)_etc_hosts:=${(s: :)${(ps:\t:)${${(f)~~"$(</etc/hosts)"}%%\#*}##[:blank:]#[^[:blank:]]#}}} || _etc_hosts=()
# hosts=(
#   "$_ssh_config[@]"
#   "$_global_ssh_hosts[@]"
#   "$_ssh_hosts[@]"
#   "$_etc_hosts[@]"
#   "$HOST"
#   localhost
# )
# zstyle ':completion:*:hosts' hosts $hosts
zstyle ':completion:*' users off

# Use caching so that commands like apt and dpkg complete are useable
zstyle ':completion::complete:*' use-cache 1
zstyle ':completion::complete:*' cache-path $ZSH/cache/

# Don't complete uninteresting users
# zstyle ':completion:*:*:*:users' ignored-patterns \
#         adm amanda apache avahi beaglidx bin cacti canna clamav daemon \
#         dbus distcache dovecot fax ftp games gdm gkrellmd gopher \
#         hacluster haldaemon halt hsqldb ident junkbust ldap lp mail \
#         mailman mailnull mldonkey mysql nagios \
#         named netdump news nfsnobody nobody nscd ntp nut nx openvpn \
#         operator pcap postfix postgres privoxy pulse pvm quagga radvd \
#         rpc rpcuser rpm shutdown squid sshd sync uucp vcsa xfs

# ... unless we really want to.
zstyle '*' single-ignored show

# if [ "x$COMPLETION_WAITING_DOTS" = "xtrue" ]; then
#   expand-or-complete-with-dots() {
#     echo -n "\e[31m......\e[0m"
#     zle expand-or-complete
#     zle redisplay
#   }
#   zle -N expand-or-complete-with-dots
#   bindkey "^I" expand-or-complete-with-dots
# fi


## correction

alias man='nocorrect man'
alias mv='nocorrect mv'
alias mysql='nocorrect mysql'
alias mkdir='nocorrect mkdir'
# alias gist='nocorrect gist'
# alias heroku='nocorrect heroku'
# alias ebuild='nocorrect ebuild'
# alias hpodder='nocorrect hpodder'
alias sudo='nocorrect sudo'

# if [[ "$ENABLE_CORRECTION" == "true" ]]; then
#   setopt correct_all
# fi


## directories

# Changing/making/removing directory
setopt auto_name_dirs
setopt auto_pushd
setopt pushd_ignore_dups
setopt pushdminus

alias ..='cd ..'
alias cd..='cd ..'
alias cd...='cd ../..'
alias cd....='cd ../../..'
alias cd.....='cd ../../../..'
alias cd/='cd /'

alias 1='cd -'
alias 2='cd -2'
alias 3='cd -3'
alias 4='cd -4'
alias 5='cd -5'
alias 6='cd -6'
alias 7='cd -7'
alias 8='cd -8'
alias 9='cd -9'

# cd () {
#   if   [[ "x$*" == "x..." ]]; then
#     cd ../..
#   elif [[ "x$*" == "x...." ]]; then
#     cd ../../..
#   elif [[ "x$*" == "x....." ]]; then
#     cd ../../../..
#   elif [[ "x$*" == "x......" ]]; then
#     cd ../../../../..
#   elif [ -d ~/.autoenv ]; then
#     source ~/.autoenv/activate.sh
#     autoenv_cd "$@"
#   else
#     builtin cd "$@"
#   fi
# }

alias md='mkdir -p'
alias rd=rmdir
alias d='dirs -v | head -10'


## functions

function zsh_stats() {
  history | awk '{CMD[$2]++;count++;}END { for (a in CMD)print CMD[a] " " CMD[a]/count*100 "% " a;}' | grep -v "./" | column -c3 -s " " -t | sort -nr | nl |  head -n20
}

# function take() {
#   mkdir -p $1
#   cd $1
# }

#
# Get the value of an alias.
#
# Arguments:
#    1. alias - The alias to get its value from
# STDOUT:
#    The value of alias $1 (if it has one).
# Return value:
#    0 if the alias was found,
#    1 if it does not exist
#
# function alias_value() {
#     alias "$1" | sed "s/^$1='\(.*\)'$/\1/"
#     test $(alias "$1")
# }

#
# Try to get the value of an alias,
# otherwise return the input.
#
# Arguments:
#    1. alias - The alias to get its value from
# STDOUT:
#    The value of alias $1, or $1 if there is no alias $1.
# Return value:
#    Always 0
#
# function try_alias_value() {
#     alias_value "$1" || echo "$1"
# }

#
# Set variable "$1" to default value "$2" if "$1" is not yet defined.
#
# Arguments:
#    1. name - The variable to set
#    2. val  - The default value
# Return value:
#    0 if the variable exists, 3 if it was set
#
function default() {
    test `typeset +m "$1"` && return 0
    typeset -g "$1"="$2"   && return 3
}

#
# Set enviroment variable "$1" to default value "$2" if "$1" is not yet defined.
#
# Arguments:
#    1. name - The env variable to set
#    2. val  - The default value
# Return value:
#    0 if the env variable exists, 3 if it was set
#
function env_default() {
    env | grep -q "^$1=" && return 0
    export "$1=$2"       && return 3
}


## grep

# export GREP_COLOR='1;32'


## history

## Command history configuration
if [ -z $HISTFILE ]; then
    HISTFILE=$HOME/.zsh_history
fi
HISTSIZE=10000
SAVEHIST=10000

setopt append_history
setopt extended_history
setopt hist_expire_dups_first
setopt hist_ignore_dups # ignore duplication command history list
setopt hist_ignore_space
setopt hist_verify
setopt inc_append_history
setopt share_history # share command history data


## key-bindings

bindkey -e
bindkey '\ew' kill-region
bindkey '^r' history-incremental-search-backward
bindkey "^[[5~" up-line-or-history
bindkey "^[[6~" down-line-or-history

# make search up and down work, so partially type and hit up/down to find relevant stuff
bindkey "${key[Up]}" up-line-or-search
# bindkey '^[[A' up-line-or-search
bindkey "${key[Down]}" down-line-or-search
# bindkey '^[[B' down-line-or-search

bindkey "^[[H" beginning-of-line
bindkey "^[[1~" beginning-of-line
bindkey "^[OH" beginning-of-line
bindkey "^[[F"  end-of-line
bindkey "^[[4~" end-of-line
bindkey "^[OF" end-of-line
bindkey ' ' magic-space    # also do history expansion on space

bindkey "^[[1;5C" forward-word
bindkey "^[[1;5D" backward-word

bindkey '^[[Z' reverse-menu-complete

# Make the delete key (or Fn + Delete on the Mac) work instead of outputting a ~
bindkey '^?' backward-delete-char
bindkey "^[[3~" delete-char
bindkey "^[3;5~" delete-char
bindkey "\e[3~" delete-char

# Edit the current command line in $EDITOR
autoload -U edit-command-line
zle -N edit-command-line
bindkey '\C-x\C-e' edit-command-line

# consider emacs keybindings:

#bindkey -e  ## emacs key bindings
#
#bindkey '^[[A' up-line-or-search
#bindkey '^[[B' down-line-or-search
#bindkey '^[^[[C' emacs-forward-word
#bindkey '^[^[[D' emacs-backward-word
#
#bindkey -s '^X^Z' '%-^M'
#bindkey '^[e' expand-cmd-path
#bindkey '^[^I' reverse-menu-complete
#bindkey '^X^N' accept-and-infer-next-history
#bindkey '^W' kill-region
#bindkey '^I' complete-word
## Fix weird sequence that rxvt produces
#bindkey -s '^[[Z' '\t'
#


## misc

## smart urls
# autoload -U url-quote-magic
# zle -N self-insert url-quote-magic

## file rename magick
bindkey "^[m" copy-prev-shell-word

## jobs
# setopt long_list_jobs

## pager
export PAGER="less"
export LESS="-R"

export LC_CTYPE=$LANG


## spectrum

# A script to make using 256 colors in zsh less painful.
# P.C. Shyamshankar <sykora@lucentbeing.com>
# Copied from http://github.com/sykora/etc/blob/master/zsh/functions/spectrum/

# typeset -Ag FX FG BG
#
# FX=(
#     reset     "%{[00m%}"
#     bold      "%{[01m%}" no-bold      "%{[22m%}"
#     italic    "%{[03m%}" no-italic    "%{[23m%}"
#     underline "%{[04m%}" no-underline "%{[24m%}"
#     blink     "%{[05m%}" no-blink     "%{[25m%}"
#     reverse   "%{[07m%}" no-reverse   "%{[27m%}"
# )
#
# for color in {000..255}; do
#     FG[$color]="%{[38;5;${color}m%}"
#     BG[$color]="%{[48;5;${color}m%}"
# done

# Show all 256 colors with color number
# function spectrum_ls() {
#   for code in {000..255}; do
#     print -P -- "$code: %F{$code}Test%f"
#   done
# }

# Show all 256 colors where the background is set to specific color
# function spectrum_bls() {
#   for code in {000..255}; do
#     ((cc = code + 1))
#     print -P -- "$BG[$code]$code: Test %{$reset_color%}"
#   done
# }


# termsupport

# #usage: title short_tab_title looooooooooooooooooooooggggggg_windows_title
# #http://www.faqs.org/docs/Linux-mini/Xterm-Title.html#ss3.1
# #Fully support screen, iterm, and probably most modern xterm and rxvt
# #Limited support for Apple Terminal (Terminal can't set window or tab separately)
# function title {
#   if [[ "$DISABLE_AUTO_TITLE" == "true" ]] || [[ "$EMACS" == *term* ]]; then
#     return
#   fi
#   if [[ "$TERM" == screen* ]]; then
#     print -Pn "\ek$1:q\e\\" #set screen hardstatus, usually truncated at 20 chars
#   elif [[ "$TERM" == xterm* ]] || [[ $TERM == rxvt* ]] || [[ $TERM == ansi ]] || [[ "$TERM_PROGRAM" == "iTerm.app" ]]; then
#     print -Pn "\e]2;$2:q\a" #set window name
#     print -Pn "\e]1;$1:q\a" #set icon (=tab) name (will override window name on broken terminal)
#   fi
# }
#
# ZSH_THEME_TERM_TAB_TITLE_IDLE="%15<..<%~%<<" #15 char left truncated PWD
# ZSH_THEME_TERM_TITLE_IDLE="%n@%m: %~"
#
# #Appears when you have the prompt
# function omz_termsupport_precmd {
#   title $ZSH_THEME_TERM_TAB_TITLE_IDLE $ZSH_THEME_TERM_TITLE_IDLE
# }
#
# #Appears at the beginning of (and during) of command execution
# function omz_termsupport_preexec {
#   emulate -L zsh
#   setopt extended_glob
#   local CMD=${1[(wr)^(*=*|sudo|ssh|rake|-*)]} #cmd name only, or if this is sudo or ssh, the next cmd
#   local LINE="${2:gs/$/\\$}"
#   LINE="${LINE:gs/%/%%}"
#   title "$CMD" "%100>...>$LINE%<<"
# }
#
# autoload -U add-zsh-hook
# add-zsh-hook precmd  omz_termsupport_precmd
# add-zsh-hook preexec omz_termsupport_preexec



## theme-and-apparence

# ls colors
autoload colors; colors;
# export LSCOLORS="Gxfxcxdxbxegedabagacad"
#export LS_COLORS

# # Enable ls colors
# if [ "$DISABLE_LS_COLORS" != "true" ]
# then
#   # Find the option for using colors in ls, depending on the version: Linux or BSD
#   if [[ "$(uname -s)" == "NetBSD" ]]; then
#     # On NetBSD, test if "gls" (GNU ls) is installed (this one supports colors);
#     # otherwise, leave ls as is, because NetBSD's ls doesn't support -G
#     gls --color -d . &>/dev/null 2>&1 && alias ls='gls --color=tty'
#   elif [[ "$(uname -s)" == "OpenBSD" ]]; then
#     # On OpenBSD, test if "colorls" is installed (this one supports colors);
#     # otherwise, leave ls as is, because OpenBSD's ls doesn't support -G
#     colorls -G -d . &>/dev/null 2>&1 && alias ls='colorls -G'
#   else
#     ls --color -d . &>/dev/null 2>&1 && alias ls='ls --color=tty' || alias ls='ls -G'
#   fi
# fi

#setopt no_beep
setopt auto_cd
# setopt multios
# setopt cdablevarS
#
# if [[ x$WINDOW != x ]]
# then
#     SCREEN_NO="%B$WINDOW%b "
# else
#     SCREEN_NO=""
# fi
#
# # Apply theming defaults
# PS1="%n@%m:%~%# "
#
# # git theming default: Variables for theming the git info prompt
# ZSH_THEME_GIT_PROMPT_PREFIX="git:("         # Prefix at the very beginning of the prompt, before the branch name
# ZSH_THEME_GIT_PROMPT_SUFFIX=")"             # At the very end of the prompt
# ZSH_THEME_GIT_PROMPT_DIRTY="*"              # Text to display if the branch is dirty
# ZSH_THEME_GIT_PROMPT_CLEAN=""               # Text to display if the branch is clean
#
# Setup the prompt with pretty colors
setopt prompt_subst
#






# Set ZSH_CUSTOM to the path where your custom config files
# and plugins exists, or else we will use the default custom/
# if [[ -z "$ZSH_CUSTOM" ]]; then
#     ZSH_CUSTOM="$ZSH/custom"
# fi


# is_plugin() {
#   local base_dir=$1
#   local name=$2
#   test -f $base_dir/plugins/$name/$name.plugin.zsh \
#     || test -f $base_dir/plugins/$name/_$name
# }
# Add all defined plugins to fpath. This must be done
# before running compinit.
# for plugin ($plugins); do
#   if is_plugin $ZSH_CUSTOM $plugin; then
#     fpath=($ZSH_CUSTOM/plugins/$plugin $fpath)
#   elif is_plugin $ZSH $plugin; then
#     fpath=($ZSH/plugins/$plugin $fpath)
#   fi
# done

# Figure out the SHORT hostname
# if [ -n "$commands[scutil]" ]; then
#   # OS X
#   SHORT_HOST=$(scutil --get ComputerName)
# else
#   SHORT_HOST=${HOST/.*/}
# fi

# Save the location of the current completion dump file.
ZSH_COMPDUMP="${ZDOTDIR:-${HOME}}/.zcompdump-${SHORT_HOST}-${ZSH_VERSION}"

# Load and run compinit
autoload -U compinit
compinit -i -d "${ZSH_COMPDUMP}"

# Load all of the plugins that were defined in ~/.zshrc
# for plugin ($plugins); do
#   if [ -f $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh ]; then
#     source $ZSH_CUSTOM/plugins/$plugin/$plugin.plugin.zsh
#   elif [ -f $ZSH/plugins/$plugin/$plugin.plugin.zsh ]; then
#     source $ZSH/plugins/$plugin/$plugin.plugin.zsh
#   fi
# done

# Load all of your custom configurations from custom/
# for config_file ($ZSH_CUSTOM/*.zsh(N)); do
#   source $config_file
# done
# unset config_file

PROMPT='%{$bg[grey]%}%{$fg[cyan]%}%3~%{$reset_color%}!%{$fg_bold[grey]%}%h%(?.%{$fg_no_bold[green]%}.%{$fg[red]%}?%?%{$fg_no_bold[red]%})$%{$reset_color%} '
#PROMPT='%{$bg[black]%}%{$fg_bold[cyan]%}%3~%{$reset_color%}!%{$fg_bold[grey]%}%h%(?.%{$fg[green]%}.%{$fg_no_bold[red]%}?%?%{$fg_bold[red]%})$%{$reset_color%} '
if [ $SHLVL -gt 1 ]; then
  PROMPT='%{$fg[yellow]%}[$SHLVL]'"$PROMPT"
fi
if [ "$USER" = root ]; then
  PROMPT='%{$fg_bold[red]%}root%{$fg_no_bold[green]%}@%{$fg[yellow]%}%m%{$fg_bold[magenta]%}:'"$PROMPT"
fi

# RPROMPT='%{$fg[red]%}%6~$(git_prompt_info)$(svn_prompt_info)%{$reset_color%}'
RPROMPT='%{$fg[red]%}%6~%{$reset_color%}'
PS2='%{$fg[green]%}>%{$reset_color%}'
